<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>W-Fragen LEGO Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-image: linear-gradient(to right top, #2dd4bf, #4ade80, #86efac, #a7f3d0, #ccfbf1); /* Teal/Green Gradient */
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            margin: 0;
            padding: 24px; 
            color: #374151; 
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent; 
        }
        .card {
            background-color: white;
            padding: 24px; 
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            text-align: center;
            width: 100%;
            max-width: 900px; 
        }
        @media (min-width: 768px) { .card { padding: 32px; } }

        .mode-title { font-size: 1.75rem; font-weight: 700; color: #0d9488; margin-bottom: 4px; }
        .mode-title-subtitle { font-size: 1rem; color: #0f766e; margin-bottom: 24px; }

        .pools-container { display: flex; flex-direction: column; gap: 1.5rem; margin-bottom: 2rem; }
        @media (min-width: 768px) { .pools-container { flex-direction: row; justify-content: space-around; } }

        .items-pool {
            background-color: #f0fdfa; border: 2px dashed #5eead4; border-radius: 0.75rem;
            padding: 1rem; min-height: 100px; display: flex; flex-wrap: wrap;
            gap: 0.75rem; justify-content: center; align-items: flex-start; flex: 1;
        }
        .items-pool h3 { width: 100%; text-align: center; font-size: 1.125rem; font-weight: 600; color: #115e59; margin-bottom: 0.75rem; }
        
        .draggable-item {
            background-image: linear-gradient(to right, #5eead4 0%, #2dd4bf 100%); 
            color: #134e4a; 
            padding: 8px 16px; /* Slightly reduced padding for potentially more text */
            border-radius: 9999px; cursor: grab; font-weight: 600; 
            font-size: 0.95rem; /* Slightly reduced font size */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); 
            transition: all 0.2s ease-out; border: 2px solid transparent; 
            user-select: none; -webkit-user-select: none; -ms-user-select: none;
            line-height: 1.3; /* Adjust line height */
        }
        .draggable-item .german-answer { display: block; }
        .draggable-item .spanish-answer-translation {
            display: block;
            font-size: 0.7rem; /* Smaller for translation */
            font-style: italic;
            color: #0f766e; /* Darker teal for contrast */
            margin-top: 2px;
        }
         /* Dark mode adjustment for Spanish answer translation */
        @media (prefers-color-scheme: dark) {
            .draggable-item { color: #e5e7eb; } /* Ensure main draggable text is light */
            .draggable-item .spanish-answer-translation { color: #9ca3af; /* gray-400 */ }
            .draggable-item.correct .spanish-answer-translation,
            .draggable-item.incorrect .spanish-answer-translation {
                color: white; 
                opacity: 0.85;
            }
        }

        .draggable-item:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        .draggable-item.dragging { opacity: 0.6; transform: rotate(3deg) scale(0.95); cursor: grabbing; }

        #question-slots-container { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-bottom: 1.5rem; }
        .question-slot-row {
            background-color: #f8fafc; border-radius: 0.75rem; padding: 1rem;
            display: flex; flex-direction: column; align-items: stretch; 
            gap: 0.75rem; border: 1px solid #e2e8f0; 
        }
        @media (min-width: 768px) { .question-slot-row { flex-direction: row; align-items: center; } }
        
        .drop-box {
            min-height: 50px; background-color: #eef2ff; border-radius: 0.5rem; 
            border: 2px dashed #a5b4fc; display: flex; justify-content: center; 
            align-items: center; transition: all 0.25s ease-in-out;
            padding: 0.5rem; flex-basis: 120px; flex-grow: 1;
        }
        @media (min-width: 768px) { .drop-box { flex-basis: 150px; } }

        .drop-box.drag-over { background-color: #ccfbf1; border-color: #5eead4; transform: scale(1.02); }
        
        .question-stem-container { text-align: center; flex-grow: 2; padding: 0 0.5rem; }
        .question-stem-text.german { display: block; font-size: 1rem; color: #475569; }
        .question-stem-text.spanish { display: block; font-size: 0.8rem; color: #64748b; font-style: italic; margin-top: 2px;}
        @media (min-width: 768px) { .question-stem-text.german { font-size: 1.125rem; } }


        .drop-box.filled .draggable-item { cursor: default; }
        .drop-box.correct .draggable-item { background-image: linear-gradient(to right, #86efac 0%, #34d399 100%); color: white; border-color: #10b981; }
        .drop-box.incorrect .draggable-item { background-image: linear-gradient(to right, #fca5a5 0%, #f87171 100%); color: white; border-color: #ef4444; }
        
        .correct-answer-reveal { font-size: 0.875rem; color: #059669; margin-top: 0.25rem; text-align: center; }
        @media (min-width: 768px) { .correct-answer-reveal { margin-left: 10px; text-align: left; } }


        .btn {
            padding: 12px 24px; border-radius: 8px; font-size: 1rem; font-weight: 600;
            color: white; cursor: pointer; transition: all 0.3s ease;
            border: none; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            margin-top: 16px;
        }
        .btn:disabled { background-color: #d1d5db !important; color: #6b7280 !important; cursor: not-allowed; opacity: 0.7; }
        .btn-primary { background-color: #14b8a6; } 
        .btn-primary:hover:not(:disabled) { background-color: #0d9488; } 
        .btn-secondary { background-color: #64748b; } 
        .btn-secondary:hover:not(:disabled) { background-color: #475569; } 
        .hidden { display: none !important; }
        .feedback-area { margin-top: 1.5rem; padding: 0.75rem; border-radius: 0.5rem; font-weight: 600; }
        .feedback-area.success { background-color: #dcfce7; color: #166534; border: 1px solid #6ee7b7;} 
        .feedback-area.some-correct { background-color: #fef3c7; color: #b45309; border: 1px solid #fcd34d;} 
        .bottom-controls { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap;}

    </style>
</head>
<body>
    <div class="card">
        <h1 class="mode-title">W-Fragen LEGO-Style</h1>
        <p class="mode-title-subtitle">Modo LEGO de Preguntas-W</p>

        <div class="pools-container">
            <div id="wfragen-pool" class="items-pool">
                <h3>W-Fragen / Preguntas-W</h3>
            </div>
            <div id="answers-pool" class="items-pool">
                <h3>Antworten / Respuestas</h3>
            </div>
        </div>

        <div id="question-slots-container">
            </div>
        
        <div id="feedback-message" class="feedback-area hidden"></div>

        <div class="bottom-controls">
            <button id="check-answers-btn" class="btn btn-primary">Check Answers / Verificar Respuestas</button>
            <button id="next-set-btn" class="btn btn-secondary hidden">Next Set / Siguiente Grupo</button>
            <a href="index.html" class="btn btn-secondary">Menu / Menú</a>
        </div>
    </div>

    <script>
        let allWFragenData = [];
        let currentQuestionSet = [];
        let questionsPerRound = 4;

        let draggedItem = null;
        let touchOffsetX = 0, touchOffsetY = 0;
        let activeTouchClone = null;

        const wFragenPoolEl = document.getElementById('wfragen-pool');
        const answersPoolEl = document.getElementById('answers-pool');
        const questionSlotsContainerEl = document.getElementById('question-slots-container');
        const checkAnswersBtn = document.getElementById('check-answers-btn');
        const nextSetBtn = document.getElementById('next-set-btn');
        const feedbackMessageEl = document.getElementById('feedback-message');

        async function loadWFragenData() {
            try {
                const response = await fetch('wfragen.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                allWFragenData = await response.json();
                if (allWFragenData.length === 0) throw new Error("wfragen.json is empty or not found.");
                initializeWFragenMode();
            } catch (error) {
                console.error("Could not load W-Fragen data:", error);
                questionSlotsContainerEl.innerHTML = `<p class="text-red-500 font-semibold">Error: Could not load questions. Please check console and wfragen.json file. Details: ${error.message}</p>`;
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function createDraggableItem(text, type, id, spanishText = '') {
            const item = document.createElement('div');
            item.classList.add('draggable-item');
            item.draggable = true;
            item.dataset.type = type; 
            item.dataset.id = id; 
            item.dataset.text = text; 

            if (type === 'answer' && spanishText) {
                item.innerHTML = `<span class="german-answer">${text}</span><span class="spanish-answer-translation">${spanishText}</span>`;
            } else {
                item.textContent = text; // W-Fragen typically don't need an internal span for translation
            }
            
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('touchstart', handleTouchStart, { passive: false });
            item.addEventListener('click', handleClickOnPlacedItem);
            item.clickHandlerAdded = true; // Assume listener added for simplicity
            return item;
        }

        function handleClickOnPlacedItem(e) {
            const item = e.target.closest('.draggable-item');
            if (item && item.parentElement && item.parentElement.classList.contains('drop-box')) {
                const originalPool = item.dataset.type === 'wfrage' ? wFragenPoolEl : answersPoolEl;
                
                item.parentElement.classList.remove('correct', 'incorrect');
                const slotRow = item.closest('.question-slot-row');
                if (slotRow) {
                    const oldReveal = slotRow.querySelector('.correct-answer-reveal');
                    if (oldReveal) oldReveal.remove();
                }
                
                originalPool.appendChild(item); 
                item.draggable = true; 
            }
        }
        
        function initializeWFragenMode() {
            shuffleArray(allWFragenData);
            currentQuestionSet = allWFragenData.slice(0, Math.min(questionsPerRound, allWFragenData.length));

            if (currentQuestionSet.length === 0) {
                 questionSlotsContainerEl.innerHTML = `<p class="text-slate-500 font-semibold">Alle Fragen geübt! Lade die Seite neu für mehr.</p>`;
                 checkAnswersBtn.classList.add('hidden');
                 nextSetBtn.classList.add('hidden');
                 wFragenPoolEl.innerHTML = '<h3>W-Fragen / Preguntas-W</h3>';
                 answersPoolEl.innerHTML = '<h3>Antworten / Respuestas</h3>';
                 return;
            }

            wFragenPoolEl.innerHTML = '<h3>W-Fragen / Preguntas-W</h3>'; 
            const wFragenRequiredForRound = currentQuestionSet.map(q => q.wFrage);
            shuffleArray(wFragenRequiredForRound);
            wFragenRequiredForRound.forEach((wfrageText, index) => {
                wFragenPoolEl.appendChild(createDraggableItem(wfrageText, 'wfrage', wfrageText + "_" + index));
            });

            answersPoolEl.innerHTML = '<h3>Antworten / Respuestas</h3>'; 
            const answersForPool = currentQuestionSet.map(q => ({ text: q.answer, id: q.id, text_es: q.answer_es }));
            shuffleArray(answersForPool);
            answersForPool.forEach(ans => {
                answersPoolEl.appendChild(createDraggableItem(ans.text, 'answer', ans.id, ans.text_es));
            });
            
            questionSlotsContainerEl.innerHTML = '';
            currentQuestionSet.forEach(qData => {
                const slotRow = document.createElement('div');
                slotRow.classList.add('question-slot-row');
                slotRow.dataset.correctWfrage = qData.wFrage;
                slotRow.dataset.correctAnswerId = qData.id;

                const wFrageDropBox = document.createElement('div');
                wFrageDropBox.classList.add('drop-box', 'wfrage-drop-target');
                wFrageDropBox.dataset.targetType = 'wfrage';

                const stemContainer = document.createElement('div');
                stemContainer.classList.add('question-stem-container'); 
                
                const stemTextDe = document.createElement('span');
                stemTextDe.classList.add('question-stem-text', 'german');
                stemTextDe.textContent = qData.questionStem.replace('___', '...');
                stemContainer.appendChild(stemTextDe);

                if (qData.questionStem_es) {
                    const stemTextEs = document.createElement('span');
                    stemTextEs.classList.add('question-stem-text', 'spanish');
                    stemTextEs.textContent = qData.questionStem_es.replace('___', '...');
                    stemContainer.appendChild(stemTextEs);
                }

                const answerDropBox = document.createElement('div');
                answerDropBox.classList.add('drop-box', 'answer-drop-target');
                answerDropBox.dataset.targetType = 'answer';

                [wFrageDropBox, answerDropBox].forEach(box => {
                    box.addEventListener('dragover', handleDragOver);
                    box.addEventListener('dragenter', handleDragEnter);
                    box.addEventListener('dragleave', handleDragLeave);
                    box.addEventListener('drop', handleDrop);
                });
                
                slotRow.appendChild(wFrageDropBox);
                slotRow.appendChild(stemContainer); // Add the container with both stems
                slotRow.appendChild(answerDropBox);
                questionSlotsContainerEl.appendChild(slotRow);
            });

            checkAnswersBtn.disabled = false;
            checkAnswersBtn.classList.remove('hidden');
            nextSetBtn.classList.add('hidden');
            feedbackMessageEl.classList.add('hidden');
            feedbackMessageEl.textContent = '';
        }

        function handleDragStart(e) {
            draggedItem = e.target.closest('.draggable-item'); // Ensure we get the item itself
            e.dataTransfer.setData('text/plain', draggedItem.dataset.id); 
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => draggedItem.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            draggedItem = null;
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const dropTarget = e.target.closest('.drop-box');
            if (draggedItem && dropTarget && dropTarget.dataset.targetType === draggedItem.dataset.type && !dropTarget.firstChild) {
                dropTarget.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const dropTarget = e.target.closest('.drop-box');
            if (dropTarget) {
                dropTarget.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropTarget = e.target.closest('.drop-box');
            if (dropTarget && draggedItem && dropTarget.dataset.targetType === draggedItem.dataset.type) {
                if (!dropTarget.firstChild) { 
                    dropTarget.appendChild(draggedItem);
                    draggedItem.classList.remove('dragging');
                }
            }
            if (dropTarget) dropTarget.classList.remove('drag-over');
            draggedItem = null;
        }
        
        function handleTouchStart(e) {
            draggedItem = e.target.closest('.draggable-item');
            if (draggedItem) {
                if (e.cancelable) e.preventDefault();

                activeTouchClone = draggedItem.cloneNode(true);
                activeTouchClone.classList.add('dragging');
                activeTouchClone.style.position = 'fixed';
                activeTouchClone.style.pointerEvents = 'none'; 
                activeTouchClone.style.zIndex = '1000';
                activeTouchClone.style.width = draggedItem.offsetWidth + 'px';
                activeTouchClone.style.height = draggedItem.offsetHeight + 'px';
                document.body.appendChild(activeTouchClone);

                const rect = draggedItem.getBoundingClientRect();
                touchOffsetX = e.touches[0].clientX - rect.left;
                touchOffsetY = e.touches[0].clientY - rect.top;
                
                activeTouchClone.style.left = (e.touches[0].clientX - touchOffsetX) + 'px';
                activeTouchClone.style.top = (e.touches[0].clientY - touchOffsetY) + 'px';
                draggedItem.style.opacity = '0.4';

                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { once: true });
            }
        }

        function handleTouchMove(e) {
            if (activeTouchClone) {
                if (e.cancelable) e.preventDefault();
                let currentX = e.touches[0].clientX;
                let currentY = e.touches[0].clientY;
                activeTouchClone.style.left = (currentX - touchOffsetX) + 'px';
                activeTouchClone.style.top = (currentY - touchOffsetY) + 'px';
                
                document.querySelectorAll('.drop-box.drag-over').forEach(box => box.classList.remove('drag-over'));
                activeTouchClone.style.display = 'none'; 
                const elementBelow = document.elementFromPoint(currentX, currentY);
                activeTouchClone.style.display = ''; 

                if (elementBelow) {
                    const dropBoxBelow = elementBelow.closest('.drop-box');
                    if (dropBoxBelow && draggedItem && dropBoxBelow.dataset.targetType === draggedItem.dataset.type && !dropBoxBelow.firstChild) {
                        dropBoxBelow.classList.add('drag-over');
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            document.removeEventListener('touchmove', handleTouchMove);
            if (activeTouchClone && draggedItem) {
                activeTouchClone.style.display = 'none';
                const dropTargetElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                let droppedSuccessfully = false;

                if (dropTargetElement) {
                    const dropBox = dropTargetElement.closest('.drop-box');
                    if (dropBox && dropBox.dataset.targetType === draggedItem.dataset.type && !dropBox.firstChild) {
                        dropBox.appendChild(draggedItem);
                        droppedSuccessfully = true;
                    }
                }
                
                if (!droppedSuccessfully) { 
                     if(draggedItem.dataset.type === 'wfrage') wFragenPoolEl.appendChild(draggedItem);
                     else answersPoolEl.appendChild(draggedItem);
                }

                draggedItem.style.opacity = '1';
                draggedItem.classList.remove('dragging');
                if(activeTouchClone.parentNode) document.body.removeChild(activeTouchClone);
            }
            activeTouchClone = null;
            draggedItem = null;
            touchOffsetX = 0;
            touchOffsetY = 0;
            document.querySelectorAll('.drop-box.drag-over').forEach(box => box.classList.remove('drag-over'));
        }


        checkAnswersBtn.addEventListener('click', () => {
            let allCorrectOverall = true; 
            let anyCorrectOverall = false; 
            let filledSlots = 0;
            let correctSlotsCount = 0; 

            questionSlotsContainerEl.querySelectorAll('.question-slot-row').forEach(slotRow => {
                const wFrageDropBox = slotRow.querySelector('.wfrage-drop-target');
                const answerDropBox = slotRow.querySelector('.answer-drop-target');
                
                const placedWFrageEl = wFrageDropBox.querySelector('.draggable-item');
                const placedAnswerEl = answerDropBox.querySelector('.draggable-item');

                let wFrageCorrect = false;
                let answerCorrect = false;

                wFrageDropBox.classList.remove('correct', 'incorrect');
                answerDropBox.classList.remove('correct', 'incorrect');
                const oldReveal = slotRow.querySelector('.correct-answer-reveal');
                if(oldReveal) oldReveal.remove();

                if (placedWFrageEl || placedAnswerEl) { 
                    filledSlots++;
                }

                if (placedWFrageEl) {
                    if (placedWFrageEl.dataset.text === slotRow.dataset.correctWfrage) {
                        wFrageDropBox.classList.add('correct');
                        wFrageCorrect = true;
                    } else {
                        wFrageDropBox.classList.add('incorrect');
                        allCorrectOverall = false;
                    }
                } else { allCorrectOverall = false; }

                if (placedAnswerEl) {
                    if (placedAnswerEl.dataset.id === slotRow.dataset.correctAnswerId) {
                        answerDropBox.classList.add('correct');
                        answerCorrect = true;
                    } else {
                        answerDropBox.classList.add('incorrect');
                        allCorrectOverall = false;
                    }
                } else { allCorrectOverall = false; }

                if (wFrageCorrect && answerCorrect) {
                    anyCorrectOverall = true;
                    correctSlotsCount++;
                } else if (placedWFrageEl || placedAnswerEl) { 
                    // Find in allWFragenData first, then fallback to currentQuestionSet if needed (though should be in current)
                    const questionData = allWFragenData.find(q => q.id === slotRow.dataset.correctAnswerId) || 
                                         currentQuestionSet.find(q => q.id === slotRow.dataset.correctAnswerId);
                    if (questionData) {
                        const revealText = document.createElement('div');
                        revealText.classList.add('correct-answer-reveal');
                        revealText.innerHTML = `Richtig / Correct: <strong class="whitespace-nowrap">${questionData.wFrage}</strong> ... <strong class="whitespace-nowrap">${questionData.answer}</strong>`;
                        
                        if(answerDropBox.nextSibling) { 
                           slotRow.insertBefore(revealText, answerDropBox.nextSibling);
                        } else {
                           slotRow.appendChild(revealText);
                        }
                    }
                }
            });
            
            checkAnswersBtn.disabled = true; 

            feedbackMessageEl.classList.remove('hidden', 'success', 'some-correct');
            if (allCorrectOverall && correctSlotsCount === currentQuestionSet.length && currentQuestionSet.length > 0) {
                feedbackMessageEl.textContent = "Super! Alles richtig! / Excellent! Everything is correct!";
                feedbackMessageEl.classList.add('success');
                triggerConfetti();
            } else if (anyCorrectOverall && currentQuestionSet.length > 0) {
                feedbackMessageEl.textContent = `Einige richtig (${correctSlotsCount}/${currentQuestionSet.length}). Schau dir die Korrekturen an. / Some correct (${correctSlotsCount}/${currentQuestionSet.length}). Check the corrections.`;
                feedbackMessageEl.classList.add('some-correct');
            } else if (currentQuestionSet.length > 0 && filledSlots > 0) { 
                feedbackMessageEl.textContent = "Leider nicht richtig. Versuch es nochmal oder schau dir die Lösungen an. / Not quite. Try again or check the solutions.";
                feedbackMessageEl.classList.add('some-correct'); 
            } else if (currentQuestionSet.length > 0 && filledSlots === 0) { 
                 feedbackMessageEl.textContent = "Bitte fülle die Lücken aus. / Please fill in the blanks.";
                 feedbackMessageEl.classList.add('some-correct');
                 checkAnswersBtn.disabled = false; 
            } else { 
                 feedbackMessageEl.textContent = "Keine Fragen zu prüfen. / No questions to check.";
                 feedbackMessageEl.classList.add('some-correct');
            }

            if (currentQuestionSet.length > 0 && (anyCorrectOverall || filledSlots > 0)) {
                nextSetBtn.classList.remove('hidden');
            }
        });

        nextSetBtn.addEventListener('click', () => {
            currentQuestionSet.forEach(usedQuestion => { // Ensure we don't immediately repeat questions from the just-completed set
                const indexInAllData = allWFragenData.findIndex(item => item.id === usedQuestion.id);
                if (indexInAllData > -1) { // move to end to deprioritize for next shuffle
                    const item = allWFragenData.splice(indexInAllData, 1)[0];
                    allWFragenData.push(item);
                }
            });
             if (allWFragenData.length < questionsPerRound && allWFragenData.length > 0) {
                questionsPerRound = allWFragenData.length;
            }
            initializeWFragenMode();
        });
        
        function triggerConfetti() { if (typeof confetti === 'function') { confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } }); } }

        loadWFragenData();
    </script>
</body>
</html>
