Of course. It's a classic string comparison issue, and your suspicion is spot on\! The problem lies in how the constructed sentence string is created and then compared to the correct answer.

The period `.` is treated as a separate word in your `german_words` array. When your code builds the sentence, it adds a space after every "word," resulting in a string with a space *before* the period (e.g., `"Ich bin aufgestanden ."`). The correct sentence string from your JSON does not have this space (`"Ich bin aufgestanden."`).

The `normalize` function in your `checkAnswer` code tries to fix this, but it fails due to the order of its operations.

Here is the corrected and improved version of your HTML file. The only change is in the `normalize` function within the `<script>` tag.

### The Fix

The issue is resolved by changing the `normalize` function to correctly handle the space before the punctuation *before* stripping the punctuation for comparison.

**Old `normalize` function:**

```javascript
const normalize = (str) => str.replace(/\s+/g, ' ').trim().toLowerCase()
    .replace(/[.!?]+\s*$/, '') // This was the problematic part in this context
    .replace(/\s+([.!?])/g, '$1');
```

**New, corrected `normalize` function:**

```javascript
const normalize = (str) => str
    .trim() // First, remove any leading/trailing whitespace.
    .replace(/\s+([.!?])/g, '$1') // **Crucially, collapse space BEFORE punctuation.** E.g., "Satz ." becomes "Satz."
    .toLowerCase() // Convert to lowercase for case-insensitive comparison.
    .replace(/[.!?]$/, ''); // Finally, remove the trailing punctuation for the comparison.
```

This new function correctly processes both the user-built string and the reference string so that they match perfectly when the words are in the correct order.

-----

### Corrected HTML File

Simply replace the content of your existing HTML file with the code below. The logic has been fixed, and no other changes are needed.

```html
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Perfekt Sentence Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-image: linear-gradient(to right top, #ddd6fe, #c7d2fe, #bfdbfe, #a7f3d0, #fed7aa); /* Purple to blue to green to orange gradient */
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            margin: 0;
            padding: 24px; 
            color: #374151; 
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent; 
        }
        .card {
            background-color: white;
            padding: 24px; 
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            text-align: center;
            width: 100%;
            max-width: 900px; 
        }
        @media (min-width: 768px) { .card { padding: 32px; } }

        .mode-title { font-size: 1.875rem; font-weight: 700; color: #7c3aed; margin-bottom: 4px; } /* Purple-600 */
        .mode-title-subtitle { font-size: 1.125rem; color: #6d28d9; margin-bottom: 24px; } /* Purple-700 */

        .reference-sentences {
            background-color: #f3e8ff; /* Purple-50 */
            padding: 1.25rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e9d5ff; /* Purple-100 */
            text-align: left;
        }
        .reference-sentences p { margin-bottom: 0.5rem; color: #581c87; /* Purple-800 */ }
        .reference-sentences strong { color: #4c1d95; /* Purple-900 */ }

        .progress-indicator {
            background-color: #ede9fe; /* Purple-100 */
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
            color: #6d28d9; /* Purple-700 */
            border: 1px solid #c4b5fd; /* Purple-300 */
        }

        .drop-zone-container {
            background-color: #f0f9ff; /* Sky-50 */
            border: 2px dashed #bae6fd; /* Sky-200 */
            border-radius: 0.75rem;
            padding: 1.25rem;
            min-height: 80px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem; 
            justify-content: flex-start;
            align-items: center; 
            margin-bottom: 1rem;
        }
       
        .draggable-item-slot {
            min-width: 60px;
            height: 50px; 
            background-color: #e0f2fe; /* Sky-100 */
            border: 1px solid #bae6fd; /* Sky-200 */
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            font-size: 0.9rem;
            padding: 0.25rem;
        }
        .draggable-item-slot.drag-over { background-color: #7dd3fc; border-color: #38bdf8; transform: scale(1.05); } /* Sky-300, Sky-400 */

        .draggable-pool {
            background-color: #faf5ff; /* Purple-25 */
            border: 2px dashed #d8b4fe; /* Purple-300 */
            border-radius: 0.75rem;
            padding: 1.25rem;
            min-height: 100px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem; 
            justify-content: center;
            align-items: center; 
            margin-bottom: 1.5rem;
        }
        .draggable-item {
            background-image: linear-gradient(to right, #c084fc 0%, #a855f7 100%); /* Purple shades */
            color: #faf5ff; /* Purple-25 */
            padding: 10px 16px; 
            border-radius: 9999px; 
            cursor: grab; 
            font-weight: 600; 
            font-size: 0.95rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); 
            transition: all 0.2s ease-out; 
            border: 2px solid transparent; 
            user-select: none; -webkit-user-select: none; -ms-user-select: none;
            text-align: center;
            min-width: 50px;
        }
        .draggable-item:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        .draggable-item.dragging { opacity: 0.6; transform: rotate(3deg) scale(0.95); cursor: grabbing; }
        .draggable-item.correct-in-slot { background-image: linear-gradient(to right, #86efac, #34d399); color: white; border-color: #10b981;}
        .draggable-item.incorrect-in-slot { background-image: linear-gradient(to right, #fca5a5, #f87171); color: white; border-color: #ef4444;}
       
        /* Enhanced clickable styling for items in slots */
        .draggable-item-slot .draggable-item { 
            cursor: pointer; 
            position: relative;
            pointer-events: auto;
        }
        .draggable-item-slot .draggable-item:hover { 
            transform: scale(1.1); 
            box-shadow: 0 0 0 3px #fbbf24, 0 10px 15px -3px rgba(0,0,0,0.1); /* Amber-400 border to indicate clickable */
            background-image: linear-gradient(to right, #f59e0b 0%, #d97706 100%) !important; /* Amber gradient on hover */
        }
        .draggable-item-slot .draggable-item:active {
            transform: scale(0.95);
        }

        .feedback-area { margin-top: 1.5rem; padding: 1rem; border-radius: 0.75rem; font-weight: 600; }
        .feedback-area.success { background-color: #dcfce7; color: #166534; border: 1px solid #6ee7b7;} 
        .feedback-area.error { background-color: #fee2e2; color: #991b1b; border: 1px solid #fca5a5;} 
       
        .btn {
            padding: 12px 24px; border-radius: 8px; font-size: 1rem; font-weight: 600;
            color: white; cursor: pointer; transition: all 0.3s ease;
            border: none; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            margin-top: 16px;
        }
        .btn:disabled { background-color: #d1d5db !important; color: #6b7280 !important; cursor: not-allowed; opacity: 0.7; }
        .btn-primary { background-color: #7c3aed; } /* Purple-600 */
        .btn-primary:hover:not(:disabled) { background-color: #6d28d9; } /* Purple-700 */
        .btn-secondary { background-color: #64748b; } 
        .btn-secondary:hover:not(:disabled) { background-color: #475569; } 
        .btn-success { background-color: #059669; }
        .btn-success:hover:not(:disabled) { background-color: #047857; }
        .hidden { display: none !important; }
        .bottom-controls { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap;}

        .help-tip {
            background-color: #fef3c7; /* Amber-100 */
            border: 1px solid #f59e0b; /* Amber-500 */
            color: #92400e; /* Amber-800 */
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .completion-message {
            background-color: #ecfdf5; /* Green-50 */
            border: 2px solid #6ee7b7; /* Green-300 */
            color: #047857; /* Green-800 */
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            font-size: 1.125rem;
            font-weight: 600;
        }

        @media (max-width: 640px) {
            .card { padding: 16px; }
            .mode-title { font-size: 1.5rem; }
            .mode-title-subtitle { font-size: 1rem; }
            .draggable-item { font-size: 0.875rem; padding: 8px 12px; }
            .draggable-item-slot { min-width: 50px; height: 45px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <div class="card">
        <h1 class="mode-title">Perfekt Sentence Practice</h1>
        <p class="mode-title-subtitle">Build German sentences in Perfekt tense</p>

        <div id="progress-container" class="progress-indicator">
            <span id="progress-text">Sentence 1 of 20</span>
        </div>

        <div id="reference-sentences-container" class="reference-sentences">
            <p><strong>English:</strong> <span id="ref-en">English sentence will appear here.</span></p>
            <p><strong>Build the German Perfekt sentence:</strong></p>
        </div>

        <div id="drop-zone-container" class="drop-zone-container">
            </div>
       
        <div class="help-tip">
            <span>ðŸ’¡</span>
            <span><strong>Tip:</strong> Click on any word bubble in the sentence above to remove it and try again!</span>
        </div>

        <div id="draggable-pool" class="draggable-pool">
            </div>
       
        <div id="feedback-message" class="feedback-area hidden"></div>
        <div id="correct-sentence-feedback" class="text-green-700 font-semibold mt-2 hidden"></div>

        <div class="bottom-controls">
            <button id="check-answer-btn" class="btn btn-primary">Check Answer</button>
            <button id="next-task-btn" class="btn btn-success hidden">Next Sentence</button>
            <button id="restart-btn" class="btn btn-secondary hidden">Start Over</button>
            <a href="index.html" class="btn btn-secondary">Menu</a>
        </div>
    </div>

    <script>
        // --- STATE MANAGEMENT ---
        let allTasks = [];
        let currentTask = null;
        let shuffledTasks = [];
        let draggedItem = null;
        let currentTaskIndex = 0;
        let totalTasks = 0;

        // --- DOM ELEMENTS ---
        const progressTextEl = document.getElementById('progress-text');
        const referenceEnEl = document.getElementById('ref-en');
        const dropZoneContainerEl = document.getElementById('drop-zone-container');
        const draggablePoolEl = document.getElementById('draggable-pool');
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const nextTaskBtn = document.getElementById('next-task-btn');
        const restartBtn = document.getElementById('restart-btn');
        const feedbackMessageEl = document.getElementById('feedback-message');
        const correctSentenceFeedbackEl = document.getElementById('correct-sentence-feedback');

        // --- INITIALIZATION ---
        async function loadTasks() {
            try {
                // Fetch data from the perfekt sentences JSON file
                const response = await fetch('perfekt_sentences.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                allTasks = await response.json();
                if (allTasks.length === 0) throw new Error("perfekt_sentences.json is empty or not found.");
               
                shuffleArray(allTasks);
                shuffledTasks = [...allTasks];
                totalTasks = shuffledTasks.length;
                currentTaskIndex = 0;
                loadNextTask();
            } catch (error) {
                console.error("Could not load tasks:", error);
                dropZoneContainerEl.innerHTML = `<p class="text-red-500 font-semibold">Error: Could not load sentences. Details: ${error.message}</p>`;
            }
        }

        // --- TASK LOGIC ---
        function loadNextTask() {
            if (shuffledTasks.length === 0) {
                // Handle completion of all tasks
                showCompletionScreen();
                return;
            }

            currentTask = shuffledTasks.shift();
            currentTaskIndex++;

            // Update progress
            progressTextEl.textContent = `Sentence ${currentTaskIndex} of ${totalTasks}`;

            // Update UI with new task data
            referenceEnEl.textContent = currentTask.translation_en;

            // Create empty slots for the words
            dropZoneContainerEl.innerHTML = '';
            currentTask.german_words.forEach(() => {
                const slot = createEmptySlot();
                dropZoneContainerEl.appendChild(slot);
            });

            // Create and shuffle draggable words
            draggablePoolEl.innerHTML = '';
            const wordsToDrag = [...currentTask.german_words, ...currentTask.distractor_words];
            shuffleArray(wordsToDrag);
            wordsToDrag.forEach(word => {
                draggablePoolEl.appendChild(createDraggableItem(word));
            });

            // Reset UI state for the new task
            resetUIForNextTask();
        }

        function showCompletionScreen() {
            dropZoneContainerEl.innerHTML = `
                <div class="completion-message">
                    <h2 class="text-2xl font-bold mb-4">ðŸŽ‰ Fantastisch!</h2>
                    <p class="mb-2">You've completed all ${totalTasks} Perfekt sentences!</p>
                    <p class="text-lg">Your German Perfekt skills are improving! ðŸ‡©ðŸ‡ªâœ¨</p>
                </div>
            `;
            draggablePoolEl.innerHTML = '';
            referenceEnEl.textContent = 'All sentences completed!';
            checkAnswerBtn.classList.add('hidden');
            nextTaskBtn.classList.add('hidden');
            restartBtn.classList.remove('hidden');
            feedbackMessageEl.classList.add('hidden');
            correctSentenceFeedbackEl.classList.add('hidden');
            document.getElementById('progress-container').classList.add('hidden');
        }
       
        function checkAnswer() {
            const slots = dropZoneContainerEl.querySelectorAll('.draggable-item-slot');
            let constructedSentence = "";
            let allSlotsFilled = true;
           
            slots.forEach(slot => {
                const item = slot.querySelector('.draggable-item');
                if (item) {
                    constructedSentence += item.dataset.text + " ";
                } else {
                    allSlotsFilled = false;
                }
            });
            constructedSentence = constructedSentence.trim();

            feedbackMessageEl.classList.remove('hidden', 'success', 'error');
            correctSentenceFeedbackEl.classList.add('hidden');

            if (!allSlotsFilled) {
                showFeedback("Please fill all blanks with words from below.", 'error');
                return;
            }

            // Normalize sentences for robust comparison (ignore punctuation)
            const normalize = (str) => str
                .trim()
                .replace(/\s+([.!?])/g, '$1') // Collapse space before punctuation: "Satz ." -> "Satz."
                .toLowerCase()
                .replace(/[.!?]$/, ''); // Remove trailing punctuation

            const isCorrect = normalize(constructedSentence) === normalize(currentTask.full_sentence_de);

            // Provide visual feedback on each word
            slots.forEach(slot => {
                const item = slot.querySelector('.draggable-item');
                if (item) {
                    item.classList.toggle('correct-in-slot', isCorrect);
                    item.classList.toggle('incorrect-in-slot', !isCorrect);
                }
            });

            if (isCorrect) {
                showFeedback("Ausgezeichnet! Perfect Perfekt sentence! âœ¨", 'success');
                triggerConfetti();
            } else {
                showFeedback("Not quite right. Try reorganizing the words.", 'error');
                correctSentenceFeedbackEl.innerHTML = `<strong>Correct order:</strong> ${currentTask.full_sentence_de}`;
                correctSentenceFeedbackEl.classList.remove('hidden');
            }
           
            // Toggle control buttons
            checkAnswerBtn.classList.add('hidden');
            nextTaskBtn.classList.remove('hidden');
        }

        function restartPractice() {
            // Reset everything and start over
            shuffleArray(allTasks);
            shuffledTasks = [...allTasks];
            currentTaskIndex = 0;
            restartBtn.classList.add('hidden');
            document.getElementById('progress-container').classList.remove('hidden');
            loadNextTask();
        }

        // --- UI & ELEMENT CREATION ---
        function createDraggableItem(text) {
            const item = document.createElement('div');
            item.className = 'draggable-item';
            item.textContent = text;
            item.draggable = true;
            item.dataset.text = text;
            // Add event listeners for both mouse and touch
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('touchstart', handleTouchStart, { passive: false });
            item.addEventListener('click', handleItemClick, true); // Use capture phase
            return item;
        }

        function createEmptySlot() {
            const slot = document.createElement('div');
            slot.className = 'draggable-item-slot';
            // Add listeners for drop events
            slot.addEventListener('dragover', handleDragOver);
            slot.addEventListener('dragenter', handleDragEnter);
            slot.addEventListener('dragleave', handleDragLeave);
            slot.addEventListener('drop', handleDrop);
            return slot;
        }

        function resetUIForNextTask() {
            feedbackMessageEl.classList.add('hidden');
            correctSentenceFeedbackEl.classList.add('hidden');
            correctSentenceFeedbackEl.textContent = '';
            checkAnswerBtn.classList.remove('hidden');
            checkAnswerBtn.disabled = false;
            nextTaskBtn.classList.add('hidden');
        }
       
        function showFeedback(message, type) {
            feedbackMessageEl.textContent = message;
            feedbackMessageEl.className = `feedback-area ${type}`;
        }

        // --- EVENT HANDLERS (DRAG & DROP + TOUCH) ---
        function handleItemClick(e) {
            console.log('Item clicked!', e.currentTarget); // Debug log
            e.preventDefault();
            e.stopPropagation();
           
            const item = e.currentTarget; // Use currentTarget instead of closest
           
            // If item is in a slot, move it back to the pool with animation
            if (item && item.parentElement && item.parentElement.classList.contains('draggable-item-slot')) {
                console.log('Moving item back to pool'); // Debug log
                const slot = item.parentElement;
               
                // Add a small animation effect
                item.style.transform = 'scale(0.8)';
                item.style.transition = 'transform 0.15s ease';
               
                setTimeout(() => {
                    slot.classList.remove('filled');
                    draggablePoolEl.appendChild(item); 
                    item.classList.remove('correct-in-slot', 'incorrect-in-slot');
                    item.style.transform = ''; // Reset transform
                    item.style.transition = ''; // Reset transition
                   
                    // Re-enable check button if we're not in results mode
                    if (nextTaskBtn.classList.contains('hidden')) {
                        checkAnswerBtn.disabled = false;
                    }
                   
                    // Clear any error feedback since user is making changes
                    if (feedbackMessageEl.classList.contains('error')) {
                        feedbackMessageEl.classList.add('hidden');
                        correctSentenceFeedbackEl.classList.add('hidden');
                    }
                }, 150);
            }
        }

        function handleDragStart(e) {
            draggedItem = e.target;
            e.dataTransfer.setData('text/plain', draggedItem.dataset.text);
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => draggedItem.classList.add('dragging'), 0);
        }

        function handleDragEnd() {
            if (draggedItem) draggedItem.classList.remove('dragging');
            draggedItem = null;
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function handleDragOver(e) { e.preventDefault(); }

        function handleDragEnter(e) {
            e.preventDefault();
            const dropTarget = e.target.closest('.draggable-item-slot');
            if (draggedItem && dropTarget && !dropTarget.firstChild) {
                dropTarget.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.target.closest('.draggable-item-slot')?.classList.remove('drag-over');
        }
       
        function handleDrop(e) {
            e.preventDefault();
            const dropTarget = e.target.closest('.draggable-item-slot');
            if (dropTarget && draggedItem && !dropTarget.firstChild) {
                dropTarget.appendChild(draggedItem);
                dropTarget.classList.add('filled');
            }
            dropTarget?.classList.remove('drag-over');
        }

        // Touch event handlers for mobile support
        let activeTouchClone = null;
        let touchOffsetX = 0, touchOffsetY = 0;

        function handleTouchStart(e) {
            draggedItem = e.target.closest('.draggable-item');
            if (!draggedItem) return;

            if (e.cancelable) e.preventDefault();
           
            // Create a visual clone for dragging
            activeTouchClone = draggedItem.cloneNode(true);
            activeTouchClone.classList.add('dragging');
            Object.assign(activeTouchClone.style, {
                position: 'fixed',
                pointerEvents: 'none',
                zIndex: '1000',
                width: `${draggedItem.offsetWidth}px`,
                height: `${draggedItem.offsetHeight}px`
            });
            document.body.appendChild(activeTouchClone);

            const rect = draggedItem.getBoundingClientRect();
            touchOffsetX = e.touches[0].clientX - rect.left;
            touchOffsetY = e.touches[0].clientY - rect.top;
           
            // Position the clone
            activeTouchClone.style.left = `${e.touches[0].clientX - touchOffsetX}px`;
            activeTouchClone.style.top = `${e.touches[0].clientY - touchOffsetY}px`;
           
            draggedItem.style.opacity = '0.4';
           
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { once: true });
        }

        function handleTouchMove(e) {
            if (!activeTouchClone) return;
            if (e.cancelable) e.preventDefault();

            let currentX = e.touches[0].clientX;
            let currentY = e.touches[0].clientY;
           
            activeTouchClone.style.left = `${currentX - touchOffsetX}px`;
            activeTouchClone.style.top = `${currentY - touchOffsetY}px`;
           
            // Highlight potential drop zone
            document.querySelectorAll('.drag-over').forEach(box => box.classList.remove('drag-over'));
            activeTouchClone.style.display = 'none'; 
            const elementBelow = document.elementFromPoint(currentX, currentY);
            activeTouchClone.style.display = ''; 
           
            const dropBoxBelow = elementBelow?.closest('.draggable-item-slot');
            if (dropBoxBelow && !dropBoxBelow.firstChild) {
                dropBoxBelow.classList.add('drag-over');
            }
        }

        function handleTouchEnd(e) {
            document.removeEventListener('touchmove', handleTouchMove);
            if (!activeTouchClone || !draggedItem) return;
           
            // Find drop target
            activeTouchClone.style.display = 'none';
            const dropTargetElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            activeTouchClone.remove(); // Clean up clone

            const dropBox = dropTargetElement?.closest('.draggable-item-slot');
            if (dropBox && !dropBox.firstChild) {
                dropBox.appendChild(draggedItem);
                dropBox.classList.add('filled');
            }
           
            draggedItem.style.opacity = '1';
            draggedItem = null;
            document.querySelectorAll('.drag-over').forEach(box => box.classList.remove('drag-over'));
        }

        // --- UTILITIES ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
       
        function triggerConfetti() {
            if (typeof confetti === 'function') {
                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            }
        }

        // --- EVENT LISTENERS ---
        checkAnswerBtn.addEventListener('click', checkAnswer);
        nextTaskBtn.addEventListener('click', loadNextTask);
        restartBtn.addEventListener('click', restartPractice);

        // --- START THE APP ---
        document.addEventListener('DOMContentLoaded', loadTasks);
    </script>
</body>
</html>
```
